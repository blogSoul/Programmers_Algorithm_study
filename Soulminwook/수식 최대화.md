# ğŸ“• Solution

```java
import java.util.*;

class Solution {
    public long answer;
    public void Calculater(ArrayList<String> calArr, ArrayList<String> expression_list){
        ArrayList<String> postFix = new ArrayList<>();
        Stack<String> cal_stack = new Stack<>();
        for(String word : expression_list){
            if(calArr.contains(word)){
                if(cal_stack.isEmpty()){
                    cal_stack.push(word);
                    continue;
                }
                while(!cal_stack.isEmpty() && calArr.indexOf(cal_stack.peek()) <= calArr.indexOf(word)){
                     postFix.add(cal_stack.pop());
                }
                cal_stack.push(word);
            } else {
                postFix.add(word);
            }
        }
        while(!cal_stack.isEmpty()){
            postFix.add(cal_stack.pop());
        }
        Stack<Long> stack = new Stack<>();
        for(String word : postFix){
            if(calArr.contains(word)){
                long b = stack.pop();
                long a = stack.pop();
                if(word.equals("+")){
                    stack.push(a + b);
                } else if(word.equals("-")){
                    stack.push(a - b);
                } else if(word.equals("*")){
                    stack.push(a * b);
                }
            } else {
                stack.push(Long.parseLong(word));
            }
        }
        answer = Math.max(answer, Math.abs(stack.pop()));
        return;
    }
    public void permutation(int count, int N, List<String> cal_list, boolean[] visited, ArrayList<String> calArr, ArrayList<String> expression_list){
        if(count == N){
            Calculater(calArr, expression_list);
            return;
        }
        for(int i = 0; i < N; i++){
            if(!visited[i]){
                visited[i] = true;
                calArr.add(cal_list.get(i));
                permutation(count + 1, N, cal_list, visited, calArr, expression_list);
                calArr.remove(calArr.size() - 1);
                visited[i] = false;
            }
        }
    }
    public long solution(String expression) {
        ArrayList<String> expression_list = new ArrayList<>();
        HashSet<String> set = new HashSet<>();
        StringBuilder sb = new StringBuilder();
        for(char word : expression.toCharArray()){
            if(word == '+' || word == '-' || word == '*'){
                expression_list.add(sb.toString());
                expression_list.add(word + "");
                set.add(word + "");
                sb.delete(0, sb.length());
            } else {
                sb.append(word);
            }
        }
        expression_list.add(sb.toString());
        ArrayList<String> calArr = new ArrayList<>();
        List<String> cal_list = new ArrayList<>(set);
        boolean[] visited = new boolean[set.size()];
        answer = 0L;
        permutation(0, cal_list.size(), cal_list, visited, calArr, expression_list);
        return answer;
    }
}
```

## ğŸ“‘ Memo

### **ğŸ“˜ ì¤‘ìœ„ í‘œê¸°ì‹ì—ì„œ í›„ìœ„ í‘œê¸°ì‹ìœ¼ë¡œ**

í”¼ì—°ì‚°ìì´ë©´ ê·¸ëŒ€ë¡œ ì¶œë ¥

1. ( ì´ë©´ ìŠ¤íƒì— push
2. ) ì´ë©´ ( ë‚˜ì˜¬ë•Œ ê¹Œì§€ ìŠ¤íƒì—ì„œ pop ê·¸ë¦¬ê³  ì¶œë ¥

ì—°ì‚°ìì´ë©´ ìŠ¤íƒì—ì„œ ì´ë³´ë‹¤ ë†’ê±°ë‚˜ ê°™ì€ ìš°ì„ ìˆœìœ„ ë“¤ì„ pop  
ê·¸ë¦¬ê³  ì´ ì—°ì‚°ìëŠ” ìŠ¤íƒì— push  
ìŠ¤íƒì— ë‚¨ì•„ ìˆëŠ” ì—°ì”ìëŠ” ëª¨ë‘ pop ê·¸ë¦¬ê³  ì¶œë ¥

### **ğŸ“˜ í›„ìœ„ í‘œê¸°ì‹ì˜ ê³„ì‚°**

í›„ìœ„ í‘œí˜„ì‹ì„ ì™¼ìª½ë¶€í„° í•œ ê¸€ìì”© ì½ì–´ì„œ

1. í”¼ì—°ì‚°ìì´ë©´, ìŠ¤íƒì— push
2. ì—°ì‚°ìë¥¼ ë§Œë‚˜ë©´ ìŠ¤íƒì—ì„œ pop â†’ (1), ë˜ pop â†’ (2)
3. (1) ì—°ì‚° (2) ì„ ê³„ì‚° ì´ ê²°ê³¼ë¥¼ ìŠ¤íƒì— push

ìˆ˜ì‹ì˜ ëì— ë„ë‹¬í•˜ë©´ ìŠ¤íƒì—ì„œ pop â†’ ì´ê²ƒì´ ê³„ì‚° ê²°ê³¼
